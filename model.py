import numpy as np
import matplotlib.pyplot as plt
from matplotlib import mpl
from time import time, clock

class Model:
    def __init__(self, k0, thickness):
        self.k0 = k0
        self.thick = thickness
        self.elements = []

    def conductivity(self, x, y):
        return self.k0

    def thickness(self, x, y):
        return self.thick

    def head(self, x, y, omit_index = 'none' ):
        """ 
        Summary:
        Returns the head above the aquifer base generated by the model
        Note:
        this accounts for the aquifer thickness so that it can handle 
        confined or unconfined sections
        """
        k = self.conductivity(x,y)
        h = self.thickness(x,y)

        phi = self.potential(x,y)

        if phi.real > (0.5 * k * pow(h, 2)):
            head = (phi.real + 0.5 * k * pow(h,2)) / (k * h)
        else:
            head = np.sqrt(2 * phi.real / k)

        return head

    def pot_from_head(self, head, x, y):
        """
        Summary: 
        Takes an external head value at a position and returns the
        corresponding real potential in the aquifer
        Note:
        this accounts for the aquifer thickness so that it can handle 
        confined or unconfined sections
        """
        k = self.conductivity(x,y)
        h = self.thickness(x,y)

        if head < h:
            pot = 0.5 * k * pow(head, 2)
        else:
            pot = k * h * head - 0.5 * k * pow(h, 2)

        return pot

    def potential(self, x, y, omit_index = 'none'):
        """ Evaluates the potential of every element in the model.
        Returns a complex number 
        """
        if self.elements != []:
            phi = complex(0., 0.)
            len(self.elements)
            for i in xrange(len(self.elements)):
                if i != omit_index:
                    phi += self.elements[i].potential(x, y)
        else:
            raise IndexError('Element list is empty')
            
        return phi

    def solve(self, tolerance, max_iterations):
        # for each element, iterate so that each element can be solved 
        # without the contribution of the potential from the other elements 
        t_init = time()

        converged = False
        iterations = 0

        #checks the residual from the previous iteration
        while converged == False:

            # sets the system residual equal to zero

            # for each element
            for i in range(0,len(self.elements)):
                converged = converged and self.elements[i].solve(omit_index = i)

            iterations += 1

        t_diff = time() - t_init
        print "Converged in {0} iterations".format(iterations)
        print "Solve took {0} seconds".format(t_diff)
        return 0

    def plot_flow_net(self, x_min, x_max, y_min, y_max, 
            nx = 5, ny = 5, n_levels = 20, fmt = 'png',
            show = False, dpi_level = 240):
        """plots the real and the complex part of the potential in a flow net.
        If the potential has a divergence term the complex part is omitted
        """
        x_lin = np.linspace(x_min, x_max, nx)
        y_lin = np.linspace(y_min, y_max, ny)
        x, y = np.meshgrid(x_lin, y_lin)
        phi = np.zeros((nx, ny))
        psi = np.zeros((nx, ny))

        for i in range(len(x_lin)):
            for j in range(len(y_lin)):
                pot = self.potential(x_lin[i], y_lin[j])
                phi[j][i] = pot.real
                psi[j][i] = pot.imag
        f = plt.figure(num = None, dpi = dpi_level, 
                facecolor = 'w', edgecolor = 'k')
        f.suptitle('model flow net')
        cmap1 = mpl.cm.jet
        cmap2 = mpl.cm.bone
        ax = f.add_subplot(111)
        p1 = ax.contour(x,y, phi, n_levels, cmap = cmap1)
        ax2 = ax.twinx()
        p2 = ax2.contour(x,y, psi, n_levels, cmap =cmap2 )
        ax.set_aspect('equal')
        ax2.set_aspect('equal')
        title = 'flow_net'
        ax.set_xlabel('x [meters]')
        ax.set_ylabel('y [meters]')
        plotframe = 0
        plt.savefig(title + '.' + fmt, bbox_inches = plotframe, format = fmt)
        if show == True:
            plt.show()
        return 0

    def plot_head_fill(self, x_min, x_max, y_min, y_max, 
            nx = 5, ny = 5, n_levels = 20, fmt = 'png',
            show = False, dpi_level = 240):
        """Plots a filled contour map of head
        """
        title = 'head_contours'
        
        x_lin = np.linspace(x_min, x_max, nx)
        y_lin = np.linspace(y_min, y_max, ny)
        x, y = np.meshgrid(x_lin, y_lin )
        head = np.zeros((nx, ny))
        for i in range(len(x_lin)):
            for j in range(len(y_lin)):
                head[j][i] = self.head(x_lin[i], y_lin[j])
        f = plt.figure(num = None, dpi = dpi_level, 
                facecolor = 'w', edgecolor = 'k')
        f.suptitle('model ' + title)
        cmap1 = mpl.cm.jet
        ax = f.add_subplot(111)
        p1 = ax.contourf(x,y, head, n_levels, cmap = cmap1)
        CB = plt.colorbar(p1, extend='both')
        ax.set_aspect('equal')
        ax.set_xlabel('x [meters]')
        ax.set_ylabel('y [meters]')
        plotframe = 0
        plt.savefig(title + '.' + fmt, bbox_inches = plotframe, format = fmt)
        if show == True:
            plt.show()
        return 0
